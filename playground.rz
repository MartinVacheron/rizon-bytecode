// for i in 5 {
//     var e = 9
//     print i
// }

// fn foo() {
//     for i in 5 {
//         var e = 9
//         print i
//     }
// }
// foo()

// fn loop() {
//     for i in 5 {
//         print i
//     }

//     var e = 0
//     if e == 0 {
//         print "oui"
//     }

//     fn test() {
//         print "test fn"
//     }
// }
// loop()


// for i in 2 {
//     var a = 4
//     for j in 3 {
//         print j + i*3
//     }
//     var i = 0
// }


// var breakfast = "beignets"
// var beverage = "cafe au lait"
// breakfast = "beignets with " + beverage
// print breakfast


// {
//     var a = 1
//     print a

//     a = 2
//     print a

//     {
//         print a
//         var a = 56
//         print a
//     }

//     print a
// }


// if true {
//     print "it's true!"
// } else {
//     print "it's false"
// }

// if !true {
//     print "it's true!"
// } else {
//     print "it's false"
// }

// if true or false {
//     print "true again"
// }
// if !false and true {
//     print "true again!!"
// }
// if true and false {
    
// } else {
//     print "false again"
// }


// var i = 0
// while i < 2 {
//     i = i + 1
//     print i
// }

// print i


// fn are_we_fn_yet() {
//     print "yes we are!"
// }

// print are_we_fn_yet


// fn add(a, b) {
//     print a + b
// }

// add(1, 2)

// fn a() { b() }
// fn b() { c() }
// fn c() {
//   c("too", "many")
// }

// a()


// fn mul(a, b) {
//     return a * b
// }

// print mul(-2, 8)


fn fib(n) {
    if n < 2 {
        return n
    }

    return fib(n - 2) + fib(n - 1)
}

var start = clock()
print fib(25)
print clock() - start


/// Closure with upvalue
// fn outer() {
//   var x = "outside"
//   fn inner() {
//     print x
//   }
//   inner()
// }
// outer()


/// Closure with upvalue that was discarded from the stack because
/// call to outer() emptys its scope/stack for ever
// fn outer() {
//   var x = "outside"
//   fn inner() {
//     print x
//   }

//   return inner
// }

// var closure = outer()
// closure()



// var globalOne
// var globalTwo

// fn main() {
//     {
//         var a = "one"
//         fn one() {
//             print a
//         }
//         globalOne = one
//     }

//     {
//         var a = "two"
//         fn two() {
//             print a
//         }
//         globalTwo = two
//     }
// }

// main()
// globalOne()
// globalTwo()


/// Closing over loop variable?
/// https://craftinginterpreters.com/closures.html#design-note
// var globalOne
// var globalTwo

// fn main() {
//     for a in 2 {
//         fn closure() {
//             print a
//         }

//         if globalOne == null {
//             globalOne = closure
//         }
//         else {
//             globalTwo = closure
//         }
//     }
// }

// main()
// globalOne()
// globalTwo()


/// Structures
// struct Pain {}
// print Pain

// struct Toast {}
// var toast = Toast()
// print toast.jam = "grape" // Prints "grape".

// struct Pair {}

// var pair = Pair()
// pair.first = 1
// pair.second = 2
// print pair.first + pair.second // 3.


/// Instances
// struct Pain {}
// print Pain()


/// Bound method
// struct Scone {
//   fn init() {}

//   fn topping(first, second) {
//     print "scone with " + first + " and " + second
//   }
// }

// var scone = Scone()
// scone.topping("berries", "cream")


/// Self
// struct CoffeeMaker {
//   fn init(coffee) {
//     self.coffee = coffee
//   }

//   fn brew() {
//     print "Enjoy your cup of " + self.coffee

//     // No reusing the grounds!
//     self.coffee = null
//   }
// }

// var maker = CoffeeMaker("coffee and chicory")
// print maker.coffee
// maker.brew()


/// Op::Invoke with a field returning a method
/// it will look for a method called 'field'
// struct Oops {
//   fn init() {
//     fn f() {
//       print "not a method"
//     }

//     self.field = f
//   }
// }

// var oops = Oops()
// oops.field()